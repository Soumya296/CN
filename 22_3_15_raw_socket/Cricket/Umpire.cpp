#include "networks.h"
#define address1 "socket1"
#define address2 "socket2"

using namespace std;

int recv_fd(int socket) 
{ 
 	int sent_fd, available_ancillary_element_buffer_space; 
 	struct msghdr socket_message; 
 	struct iovec io_vector[1]; 
	 struct cmsghdr *control_message = NULL; 
	 char message_buffer[1]; 
	 char ancillary_element_buffer[CMSG_SPACE(sizeof(int))]; 
 
 	/* start clean */ 
 	memset(&socket_message, 0, sizeof(struct msghdr)); 
 	memset(ancillary_element_buffer, 0, CMSG_SPACE(sizeof(int))); 

	 /* setup a place to fill in message contents */ 
 	io_vector[0].iov_base = message_buffer; 
 	io_vector[0].iov_len = 1; 
 	socket_message.msg_iov = io_vector; 
 	socket_message.msg_iovlen = 1; 
 
 	/* provide space for the ancillary data */ 
 	socket_message.msg_control = ancillary_element_buffer; 
 	socket_message.msg_controllen = CMSG_SPACE(sizeof(int)); 
 	if(recvmsg(socket, &socket_message, MSG_CMSG_CLOEXEC) < 0) 
 		return -1; 
 	if(message_buffer[0] != 'F') 
 	{ 
 		/* this did not originate from the above function */ 
 		return -1; 
 	} 
 	
 	if((socket_message.msg_flags & MSG_CTRUNC) == MSG_CTRUNC) 
 	{ 
 		/* we did not provide enough space for the ancillary element array */ 
 		return -1; 
 	} 
 	
 	/* iterate ancillary elements */ 
 	for(control_message = CMSG_FIRSTHDR(&socket_message); 
 	control_message != NULL; 
 	control_message = CMSG_NXTHDR(&socket_message, control_message)) 
 	{ 
 	if( (control_message->cmsg_level == SOL_SOCKET) && 
 	(control_message->cmsg_type == SCM_RIGHTS) ) 
 	{ 
 		sent_fd = *((int *) CMSG_DATA(control_message)); 
 		return sent_fd; 
 	} 
 	} 
 	return -1; 
}

int send_fd(int socket, int fd_to_send)
{
	struct msghdr socket_message;
	struct iovec io_vector[1];
	struct cmsghdr *control_message = NULL;
	char message_buffer[1];
	
	char element_buffer[CMSG_SPACE(sizeof(int))];
	int available_element_buffer_space;
	
	message_buffer[0]='F';
	io_vector[0].iov_base = message_buffer;
	io_vector[0].iov_len = 1;
	
	//initialise socket message
	memset(&socket_message, 0, sizeof(struct msghdr));
	socket_message.msg_iov = io_vector;
	socket_message.msg_iovlen = 1;
	
	//provide space for the ancillary data
	available_element_buffer_space = CMSG_SPACE(sizeof(int));
	memset(element_buffer, 0, available_element_buffer_space);
	socket_message.msg_control = element_buffer; 
 	socket_message.msg_controllen = available_element_buffer_space; 
	
 	/* initialize a single ancillary data element for fd passing */ 
 	control_message = CMSG_FIRSTHDR(&socket_message); 
 	control_message->cmsg_level = SOL_SOCKET; 
 	control_message->cmsg_type = SCM_RIGHTS; 
 	control_message->cmsg_len = CMSG_LEN(sizeof(int)); 
 	*((int *) CMSG_DATA(control_message)) = fd_to_send; 
 	
 	return sendmsg(socket, &socket_message, 0); 
}

int count1=0,flag=0;
struct timeval t0, t1;

int bowler_flag = 0;
 
void handler(int sifid,siginfo_t *info,void *context)
{
    int ppid=info->si_pid;
    count1++;
    gettimeofday(&t1, 0);
    double elapsed = (t1.tv_sec-t0.tv_sec) * 1.0f + (t1.tv_usec - t0.tv_usec) /1000000.0f;
    cout<<"batsman took "<<elapsed<<" time to respond"<<endl;
    if(elapsed>10)
    {
        flag=1;
    }
}

void handler2(int sifid,siginfo_t *info,void *context)
{
    int ppid=info->si_pid;
    gettimeofday(&t0, 0);
    double elapsed = (t1.tv_sec-t0.tv_sec) * 1.0f + (t1.tv_usec - t0.tv_usec) /1000000.0f;
    flag = 0;
	bowler_flag = 1;
}

int main(){
	
    struct sigaction act={0};
    act.sa_flags=SA_SIGINFO;
    act.sa_sigaction=&handler;
    sigaction(SIGUSR1,&act,NULL);

	struct sigaction act2={0};
    act2.sa_flags=SA_SIGINFO;
    act2.sa_sigaction=&handler2;
    sigaction(SIGUSR2,&act2,NULL);

    struct sockaddr_un userv_addr,ucli_addr; 
    int userv_len;
    int usfd = socket(AF_UNIX,SOCK_STREAM,0);
	if(usfd<=0)
		perror("socket");
	
	bzero(&userv_addr,sizeof(userv_addr));
	
	userv_addr.sun_family = AF_UNIX;
	strcpy(userv_addr.sun_path, address1);
	unlink(address1);
	userv_len = sizeof(userv_addr);
	if(bind(usfd, (struct sockaddr *)&userv_addr, userv_len)==-1)
		perror("server:bind");
	socklen_t ucli_len1;
	listen(usfd,5);



    int rsfd=socket (AF_INET, SOCK_RAW, 2);	
    char buff[100];
    recvfrom(rsfd,buff,100,0,NULL,NULL);
    struct iphdr* ip;
    ip=(struct iphdr*)buff;
    printf("r generated by batsman : %s\n",buff+(ip->ihl)*4);
    int r=atoi(buff+(ip->ihl)*4);

	while(bowler_flag == 0){}
    while(count1==0)
    {
		struct timeval t;
		gettimeofday(&t, 0);
		double elapsed = (t.tv_sec-t0.tv_sec) * 1.0f + (t.tv_usec - t0.tv_usec) /1000000.0f;
		if(elapsed>12) 
		{
			cout<<"No response from batsman"<<endl;
			exit(1);
		}

    }
    if(flag==1)
    {
        cout<<"Batsman declared out as took more than 10 seconds"<<endl;
        return 0;

    }
    if(r%4==0 || r%6==0)
    {
        if(r%12==0)
        cout<<"score of the batsman is : 6"<<endl;
        else
        cout<<"score of the batsman is : 4"<<endl;
    }
    else
    {
        int rsfd1=socket (AF_INET, SOCK_RAW, 3);	
        char buff1[100];
        recvfrom(rsfd1,buff1,100,0,NULL,NULL);
        ip=(struct iphdr*)buff;
        cout<<buff1+(ip->ihl)*4<<endl;
    }
    

    int usfd1= socket(AF_UNIX, SOCK_STREAM, 0); 
 	if(usfd1==-1) 
	 perror("\nsocket ");  
    bzero(&userv_addr,sizeof(userv_addr)); 
	userv_addr.sun_family = AF_UNIX; 
 	strcpy(userv_addr.sun_path, address2); 
	userv_len = sizeof(userv_addr);	
 	if(connect(usfd1,(struct sockaddr *)&userv_addr,userv_len)==-1) 
 		perror("\n connect "); 


    int fd=recv_fd(usfd1);
    printf("Ball recieved from batsaman : %d \n",fd);
    int nusfd1= accept(usfd,NULL,NULL);
	send_fd(nusfd1,fd);
    cout<<"ball sent back to baller"<<endl;

    return 0;
}